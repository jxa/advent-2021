<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxQBDwk3cvr1bt8YVL5m6bJGrFEmzrSbCrH1roypLjJr4AbbteCKh9Y6gQVYexdY85QA2HG5nQFLWpRp69zFSPDJ9" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxoxUgsBRs2yjjBBcfeCc8XigM7erXHmjJg2tjdGxNBxwTYuDonuYswXqRStaCA2b3rTEPCgPwixJmAVrea1qAHHU" rel="stylesheet" type="text/css"><script src="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxbYRCXwaCaT7jPRdDV8kTWPUgAhsNhahH9e1QsnosGN9nCzVcci7TnkLtMVpj2cQcbbMEDaXAK14EZ57XXSxQGat" type="text/javascript"></script></head><body><div id="clerk-static-app"></div><script>let viewer = nextjournal.clerk.sci_viewer
let app = nextjournal.clerk.static_app
let docs = viewer.read_string("{\"src/xandrews/day01.clj\" {:nextjournal/value [{:nextjournal/value \"(ns xandrews.day01\\n  (:require [clojure.java.io :as io]\\n            [clojure.string :as s]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def input-1 (slurp (io/resource \\\"day01.1.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"199\\\\n227\\\\n229\\\\n230\\\\n233\\\\n228\\\\n231\\\\n226\\\\n237\\\\n259\\\\n262\\\\n265\\\\n266\\\\n265\\\\n269\\\\n276\\\\n278\\\\n279\\\\n281\\\\n287\\\\n305\\\\n316\\\\n314\\\\n320\\\\n313\\\\n\\\" {:nextjournal/value {:path [], :count 9696, :offset 100, :remaining 9596}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def sonar-readings (map #(Integer/parseInt %) (s/split input-1 #\\\"\\\\n\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 199, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 227, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 229, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 230, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4], :nextjournal/value 233, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5], :nextjournal/value 228, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6], :nextjournal/value 231, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7], :nextjournal/value 226, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8], :nextjournal/value 237, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9], :nextjournal/value 259, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [10], :nextjournal/value 262, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [11], :nextjournal/value 265, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [12], :nextjournal/value 266, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [13], :nextjournal/value 265, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [14], :nextjournal/value 269, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [15], :nextjournal/value 276, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [16], :nextjournal/value 278, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [17], :nextjournal/value 279, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [18], :nextjournal/value 281, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [19], :nextjournal/value 287, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:nextjournal/value {:count 2000, :offset 20, :path [], :remaining 1980}, :nextjournal/viewer :elision}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Part 1\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(reduce (fn [[count prev] cur]\\n          (if (> cur prev)\\n            [(inc count) cur]\\n            [count cur]))\\n        [0 100000000000]\\n        sonar-readings)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 1446, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 6110, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Part 2\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def triple-readings\\n  \\\"return a new collection containing three consecutive values from sonar readings\\\"\\n  (map (fn [& args] args)\\n       sonar-readings\\n       (next sonar-readings)\\n       (nnext sonar-readings)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 199, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 227, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2], :nextjournal/value 229, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 227, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 229, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2], :nextjournal/value 230, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 229, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 230, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2], :nextjournal/value 233, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 230, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 233, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 2], :nextjournal/value 228, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value 233, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1], :nextjournal/value 228, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 2], :nextjournal/value 231, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [5], :nextjournal/value [{:path [5 0], :nextjournal/value 228, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5 1], :nextjournal/value 231, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5 2], :nextjournal/value 226, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [6], :nextjournal/value [{:path [6 0], :nextjournal/value 231, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6 1], :nextjournal/value 226, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6 2], :nextjournal/value 237, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [7], :nextjournal/value [{:path [7 0], :nextjournal/value 226, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7 1], :nextjournal/value 237, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7 2], :nextjournal/value 259, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [8], :nextjournal/value [{:path [8 0], :nextjournal/value 237, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8 1], :nextjournal/value 259, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8 2], :nextjournal/value 262, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [9], :nextjournal/value [{:path [9 0], :nextjournal/value 259, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9 1], :nextjournal/value 262, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9 2], :nextjournal/value 265, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [10], :nextjournal/value [{:path [10 0], :nextjournal/value 262, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [10 1], :nextjournal/value 265, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [10 2], :nextjournal/value 266, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [11], :nextjournal/value [{:path [11 0], :nextjournal/value 265, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [11 1], :nextjournal/value 266, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [11 2], :nextjournal/value 265, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [12], :nextjournal/value [{:path [12 0], :nextjournal/value 266, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [12 1], :nextjournal/value 265, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [12 2], :nextjournal/value 269, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [13], :nextjournal/value [{:path [13 0], :nextjournal/value 265, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [13 1], :nextjournal/value 269, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [13 2], :nextjournal/value 276, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [14], :nextjournal/value [{:path [14 0], :nextjournal/value 269, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [14 1], :nextjournal/value 276, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [14 2], :nextjournal/value 278, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [15], :nextjournal/value [{:path [15 0], :nextjournal/value 276, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [15 1], :nextjournal/value 278, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [15 2], :nextjournal/value 279, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [16], :nextjournal/value [{:path [16 0], :nextjournal/value 278, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [16 1], :nextjournal/value 279, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [16 2], :nextjournal/value 281, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [17], :nextjournal/value [{:path [17 0], :nextjournal/value 279, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [17 1], :nextjournal/value 281, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [17 2], :nextjournal/value 287, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [18], :nextjournal/value [{:path [18 0], :nextjournal/value 281, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [18 1], :nextjournal/value 287, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [18 2], :nextjournal/value 305, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:path [19], :nextjournal/value [{:path [19 0], :nextjournal/value 287, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [19 1], :nextjournal/value 305, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [19 2], :nextjournal/value 316, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}} {:nextjournal/value {:count 1998, :offset 20, :path [], :remaining 1978}, :nextjournal/viewer :elision}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(reduce (fn [[count prevsum] cur]\\n          (let [sum (reduce + cur)]\\n            (if (> sum prevsum)\\n              [(inc count) sum]\\n              [count sum])))\\n        [0 100000000000]\\n        triple-readings)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 1486, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 18347, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :xandrews.day01}}, \"src/xandrews/day02.clj\" {:nextjournal/value [{:nextjournal/value \"(ns xandrews.day02jk\\n  (:require [clojure.java.io :as io]\\n            [clojure.string :as s]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Part 1\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" --- Day 2: Dive! ---\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Now, you need to figure out how to pilot this thing.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" It seems like the submarine can take a series of commands like forward 1,\\n down 2, or up 3:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     forward X increases the horizontal position by X units. down X increases\\n     the depth by X units. up X decreases the depth by X units.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"{:direction :forward, :magnitude 1}\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value :forward, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Note that since you're on a submarine, down and up affect your depth, and so\\n they have the opposite result of what you might expect.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The submarine seems to already have a planned course (your puzzle input). You\\n should probably figure out where it's going. For example:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" forward 5 down 5 forward 8 up 3 down 8 forward 2\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Your horizontal position and depth both start at 0. The steps above would\\n then modify them as follows:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"{:position 0, :depth 0}\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :depth, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :position, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"     forward 5 adds 5 to your horizontal position, a total of 5. down 5 adds 5\\n     to your depth, resulting in a value of 5. forward 8 adds 8 to your\\n     horizontal position, a total of 13. up 3 decreases your depth by 3,\\n     resulting in a value of 2. down 8 adds 8 to your depth, resulting in a\\n     value of 10. forward 2 adds 2 to your horizontal position, a total of 15.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" After following these instructions, you would have a horizontal position of\\n 15 and a depth of 10. (Multiplying these together produces 150.)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Calculate the horizontal position and depth you would have after following\\n the planned course. What do you get if you multiply your final horizontal\\n position by your final depth?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" eval this if need to change move dispatch function\\n     (ns-unmap *ns* 'move)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defmulti move (fn [_ cmd] (:direction cmd)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defmethod move :forward [ {:keys [position] :as coordinates} {:keys [magnitude]}]\\n  (assoc coordinates :position (+ position magnitude)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #multifn[move 0x4297c2fc], :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defmethod move :up [{:keys [depth] :as coordinates} {:keys [magnitude]}]\\n  (assoc coordinates :depth (- depth magnitude)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #multifn[move 0x4297c2fc], :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defmethod move :down [{:keys [depth] :as coordinates} {:keys [magnitude]}]\\n  (assoc coordinates :depth (+ depth magnitude)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #multifn[move 0x4297c2fc], :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(move {:position 4, :depth 23} {:direction :forward :magnitude 2})\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :depth, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :position, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(move {:position 4, :depth 23} {:direction :up :magnitude 2})\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :depth, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :position, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(move {:position 4, :depth 23} {:direction :down :magnitude 2})\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :depth, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value 25, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :position, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def input (slurp (io/resource \\\"day02.1.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"forward 3\\\\ndown 9\\\\nforward 5\\\\nup 1\\\\nforward 2\\\\ndown 1\\\\ndown 7\\\\ndown 5\\\\nup 6\\\\nforward 3\\\\ndown 6\\\\nforward 9\\\\ndown \\\" {:nextjournal/value {:path [], :count 7732, :offset 100, :remaining 7632}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def directions (map (fn [line]\\n                       (let [[direction magnitude] (s/split line #\\\" \\\")]\\n                         {:direction (keyword direction)\\n                          :magnitude (Integer/parseInt magnitude)}))\\n                     (s/split input #\\\"\\\\n\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 0 1], :nextjournal/value :forward, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 1 1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 1 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value [{:path [2 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [2 0 1], :nextjournal/value :forward, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2 1], :nextjournal/value [{:path [2 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [2 1 1], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value [{:path [3 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [3 0 1], :nextjournal/value :up, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [3 1], :nextjournal/value [{:path [3 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [3 1 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value [{:path [4 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [4 0 1], :nextjournal/value :forward, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [4 1], :nextjournal/value [{:path [4 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [4 1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [5], :nextjournal/value [{:path [5 0], :nextjournal/value [{:path [5 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [5 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [5 1], :nextjournal/value [{:path [5 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [5 1 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [6], :nextjournal/value [{:path [6 0], :nextjournal/value [{:path [6 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [6 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [6 1], :nextjournal/value [{:path [6 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [6 1 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [7], :nextjournal/value [{:path [7 0], :nextjournal/value [{:path [7 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [7 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [7 1], :nextjournal/value [{:path [7 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [7 1 1], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [8], :nextjournal/value [{:path [8 0], :nextjournal/value [{:path [8 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [8 0 1], :nextjournal/value :up, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [8 1], :nextjournal/value [{:path [8 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [8 1 1], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [9], :nextjournal/value [{:path [9 0], :nextjournal/value [{:path [9 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [9 0 1], :nextjournal/value :forward, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [9 1], :nextjournal/value [{:path [9 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [9 1 1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [10], :nextjournal/value [{:path [10 0], :nextjournal/value [{:path [10 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [10 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [10 1], :nextjournal/value [{:path [10 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [10 1 1], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [11], :nextjournal/value [{:path [11 0], :nextjournal/value [{:path [11 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [11 0 1], :nextjournal/value :forward, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [11 1], :nextjournal/value [{:path [11 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [11 1 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [12], :nextjournal/value [{:path [12 0], :nextjournal/value [{:path [12 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [12 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [12 1], :nextjournal/value [{:path [12 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [12 1 1], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [13], :nextjournal/value [{:path [13 0], :nextjournal/value [{:path [13 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [13 0 1], :nextjournal/value :forward, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [13 1], :nextjournal/value [{:path [13 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [13 1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [14], :nextjournal/value [{:path [14 0], :nextjournal/value [{:path [14 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [14 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [14 1], :nextjournal/value [{:path [14 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [14 1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [15], :nextjournal/value [{:path [15 0], :nextjournal/value [{:path [15 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [15 0 1], :nextjournal/value :forward, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [15 1], :nextjournal/value [{:path [15 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [15 1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [16], :nextjournal/value [{:path [16 0], :nextjournal/value [{:path [16 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [16 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [16 1], :nextjournal/value [{:path [16 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [16 1 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [17], :nextjournal/value [{:path [17 0], :nextjournal/value [{:path [17 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [17 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [17 1], :nextjournal/value [{:path [17 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [17 1 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [18], :nextjournal/value [{:path [18 0], :nextjournal/value [{:path [18 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [18 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [18 1], :nextjournal/value [{:path [18 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [18 1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:path [19], :nextjournal/value [{:path [19 0], :nextjournal/value [{:path [19 0 0], :nextjournal/value :direction, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [19 0 1], :nextjournal/value :down, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [19 1], :nextjournal/value [{:path [19 1 0], :nextjournal/value :magnitude, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [19 1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}} {:nextjournal/value {:count 1000, :offset 20, :path [], :remaining 980}, :nextjournal/viewer :elision}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def final-coordinates\\n  (reduce move {:position 0, :depth 0} directions))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :depth, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value 955, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :position, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value 1957, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def answer (reduce * (vals final-coordinates)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 1868935, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Part 2\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Based on your calculations, the planned course doesn't seem to make any\\n sense. You find the submarine manual and discover that the process is\\n actually slightly more complicated.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" In addition to horizontal position and depth, you'll also need to track a\\n third value, aim, which also starts at 0. The commands also mean something\\n entirely different than you first thought:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     down X increases your aim by X units. up X decreases your aim by X units.\\n     forward X does two things: It increases your horizontal position by X\\n     units. It increases your depth by your aim multiplied by X.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Again note that since you're on a submarine, down and up do the opposite of\\n what you might expect: \\\"down\\\" means aiming in the positive direction.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Now, the above example does something different:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     forward 5 adds 5 to your horizontal position, a total of 5. Because your\\n     aim is 0, your depth does not change. down 5 adds 5 to your aim,\\n     resulting in a value of 5. forward 8 adds 8 to your horizontal position,\\n     a total of 13. Because your aim is 5, your depth increases by 8*5=40. up\\n     3 decreases your aim by 3, resulting in a value of 2. down 8 adds 8 to\\n     your aim, resulting in a value of 10. forward 2 adds 2 to your horizontal\\n     position, a total of 15. Because your aim is 10, your depth increases by\\n     2*10=20 to a total of 60.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" After following these new instructions, you would have a horizontal position\\n of 15 and a depth of 60. (Multiplying these produces 900.)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Using this new interpretation of the commands, calculate the horizontal\\n position and depth you would have after following the planned course. What do\\n you get if you multiply your final horizontal position by your final depth?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defmulti move-2 (fn [_ cmd] (:direction cmd)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defmethod move-2 :forward [{:keys [position aim depth] :as coordinates} {:keys [magnitude]}]\\n  (assoc coordinates\\n         :position (+ position magnitude)\\n         :depth (+ depth (* aim magnitude))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #multifn[move-2 0x26d5150d], :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defmethod move-2 :up [{:keys [position aim depth] :as coordinates} {:keys [magnitude]}]\\n  (assoc coordinates :aim (- aim magnitude)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #multifn[move-2 0x26d5150d], :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defmethod move-2 :down [{:keys [position aim depth] :as coordinates} {:keys [magnitude]}]\\n  (assoc coordinates :aim (+ aim magnitude)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value #multifn[move-2 0x26d5150d], :nextjournal/viewer nil}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" YOLO\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def final-coordinates-2\\n  (reduce move-2 {:position 0, :depth 0, :aim 0} directions))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value :aim, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [0 1], :nextjournal/value 955, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value :depth, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [1 1], :nextjournal/value 1004584, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value :position, :nextjournal/viewer {:pred #function+ \\\"clojure.core/keyword?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-keyword.inspected-value (str x)]))}} {:path [2 1], :nextjournal/value 1957, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def answer-2\\n  (let [{:keys [position depth]} final-coordinates-2]\\n    (* position depth)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 1965970888, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :xandrews.day02jk}}, \"src/xandrews/day03.clj\" {:nextjournal/value [{:nextjournal/value \"(ns xandrews.day03\\n  (:require [clojure.java.io :as io]\\n            [clojure.string :as s]\\n            [clojure.core.matrix :as matrix]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Day 3: Binary Diagnostic\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The submarine has been making some odd creaking noises, so you ask it to\\n produce a diagnostic report just in case.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The diagnostic report (your puzzle input) consists of a list of binary\\n numbers which, when decoded properly, can tell you many useful things about\\n the conditions of the submarine. The first parameter to check is the power\\n consumption.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" You need to use the binary numbers in the diagnostic report to generate two\\n new binary numbers (called the gamma rate and the epsilon rate). The power\\n consumption can then be found by multiplying the gamma rate by the epsilon\\n rate.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Each bit in the gamma rate can be determined by finding the most common bit\\n in the corresponding position of all numbers in the diagnostic report. For\\n example, given the following diagnostic report:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def test-input\\n  \\\"00100\\n11110\\n10110\\n10111\\n10101\\n01111\\n00111\\n11100\\n10000\\n11001\\n00010\\n01010\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"00100\\\\n11110\\\\n10110\\\\n10111\\\\n10101\\\\n01111\\\\n00111\\\\n11100\\\\n10000\\\\n11001\\\\n00010\\\\n01010\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Considering only the first bit of each number, there are five 0 bits and\\n seven 1 bits. Since the most common bit is 1, the first bit of the gamma rate\\n is 1.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Let's count the first bits\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def test-lines (s/split-lines test-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value \\\"00100\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [1], :nextjournal/value \\\"11110\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [2], :nextjournal/value \\\"10110\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [3], :nextjournal/value \\\"10111\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [4], :nextjournal/value \\\"10101\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [5], :nextjournal/value \\\"01111\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [6], :nextjournal/value \\\"00111\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [7], :nextjournal/value \\\"11100\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [8], :nextjournal/value \\\"10000\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [9], :nextjournal/value \\\"11001\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [10], :nextjournal/value \\\"00010\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [11], :nextjournal/value \\\"01010\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def first-bit-ratio\\n  (reduce (fn [[zeros ones] line]\\n            (let [[char _] line]\\n              [(+ zeros (if (= \\\\0 char) 1 0))\\n               (+ ones (if (= \\\\1 char) 1 0))]))\\n          [0 0]\\n          test-lines))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" extract the important part\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn count-bits [v]\\n  (reduce (fn [[zeros ones] c]\\n            [(+ zeros (if (= \\\\0 c) 1 0))\\n             (+ ones  (if (= \\\\1 c) 1 0))])\\n          [0 0]\\n          v))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/count-bits\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" The most common second bit of the numbers in the diagnostic report is 0, so\\n the second bit of the gamma rate is 0.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Let's generalize the counting... Bring in the matrix lib!\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" convert a string into vector of chars\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(into [] (seq \\\"100110\\\"))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-matrix\\n  (mapv #(into [] (seq %)) test-lines))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [5], :nextjournal/value [{:path [5 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [6], :nextjournal/value [{:path [6 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [7], :nextjournal/value [{:path [7 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [8], :nextjournal/value [{:path [8 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [9], :nextjournal/value [{:path [9 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [10], :nextjournal/value [{:path [10 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [11], :nextjournal/value [{:path [11 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(count-bits (nth (matrix/columns test-matrix) 0))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn gamma-bit [[zeros ones]]\\n  (if (< zeros ones) 1 0))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/gamma-bit\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(gamma-bit [5 7])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" The most common value of the third, fourth, and fifth bits are 1, 1, and 0,\\n respectively, and so the final three bits of the gamma rate are 110.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(->> test-matrix\\n     matrix/columns\\n     (map count-bits)\\n     (map gamma-bit)\\n     s/join)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"10110\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" So, the gamma rate is the binary number 10110, or 22 in decimal.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn bin->int [s]\\n  (Integer/parseInt s 2))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/bin->int\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(bin->int \\\"0010110\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 22, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" The epsilon rate is calculated in a similar way; rather than use the most\\n common bit, the least common bit from each position is used. So, the epsilon\\n rate is 01001, or 9 in decimal. Multiplying the gamma rate (22) by the\\n epsilon rate (9) produces the power consumption, 198.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn epsilon-bit [[zeros ones]]\\n  (if (> zeros ones) 1 0))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/epsilon-bit\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn calc-rate [m calc]\\n  (->> m\\n       matrix/columns\\n       (map count-bits)\\n       (map calc)\\n       s/join))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/calc-rate\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(calc-rate test-matrix gamma-bit)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"10110\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(calc-rate test-matrix epsilon-bit)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"01001\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Use the binary numbers in your diagnostic report to calculate the gamma rate\\n and epsilon rate, then multiply them together. What is the power consumption\\n of the submarine? (Be sure to represent your answer in decimal, not binary.)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def input (slurp (io/resource \\\"day03.1.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"011110111101\\\\n110010010001\\\\n111011111111\\\\n110011010100\\\\n111100000011\\\\n010101001001\\\\n010101000010\\\\n100111101\\\" {:nextjournal/value {:path [], :count 13000, :offset 100, :remaining 12900}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def input-matrix\\n  (mapv #(into [] (seq %))\\n        (s/split-lines input)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 10], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 10], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [5], :nextjournal/value [{:path [5 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [6], :nextjournal/value [{:path [6 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 10], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [7], :nextjournal/value [{:path [7 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [7 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [8], :nextjournal/value [{:path [8 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 10], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [8 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [9], :nextjournal/value [{:path [9 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [9 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [10], :nextjournal/value [{:path [10 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 10], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [10 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [11], :nextjournal/value [{:path [11 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 10], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [11 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [12], :nextjournal/value [{:path [12 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 10], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [12 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [13], :nextjournal/value [{:path [13 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [13 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [14], :nextjournal/value [{:path [14 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [14 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [15], :nextjournal/value [{:path [15 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [15 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [16], :nextjournal/value [{:path [16 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 6], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [16 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [17], :nextjournal/value [{:path [17 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [17 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [18], :nextjournal/value [{:path [18 0], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 5], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 7], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 8], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 9], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 10], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [18 11], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [19], :nextjournal/value [{:path [19 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 5], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 6], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 7], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 8], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 9], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 10], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [19 11], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:nextjournal/value {:count 1000, :offset 20, :path [], :remaining 980}, :nextjournal/viewer :elision}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(let [m input-matrix\\n      gamma (calc-rate m gamma-bit)\\n      epsilon (calc-rate m epsilon-bit)]\\n  (* (bin->int gamma)\\n     (bin->int epsilon)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 3847100, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Part Two\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Next, you should verify the life support rating, which can be determined by\\n multiplying the oxygen generator rating by the CO2 scrubber rating.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Both the oxygen generator rating and the CO2 scrubber rating are values that\\n can be found in your diagnostic report - finding them is the tricky part.\\n Both values are located using a similar process that involves filtering out\\n values until only one remains. Before searching for either rating value,\\n start with the full list of binary numbers from your diagnostic report and\\n consider just the first bit of those numbers. Then:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     Keep only numbers selected by the bit criteria for the type of rating\\n     value for which you are searching. Discard numbers which do not match the\\n     bit criteria. If you only have one number left, stop; this is the rating\\n     value for which you are searching. Otherwise, repeat the process,\\n     considering the next bit to the right.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The bit criteria depends on which type of rating value you want to find:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     To find oxygen generator rating, determine the most common value (0 or 1)\\n     in the current bit position, and keep only numbers with that bit in that\\n     position. If 0 and 1 are equally common, keep values with a 1 in the\\n     position being considered. To find CO2 scrubber rating, determine the\\n     least common value (0 or 1) in the current bit position, and keep only\\n     numbers with that bit in that position. If 0 and 1 are equally common,\\n     keep values with a 0 in the position being considered.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" For example, to determine the oxygen generator rating value using the same\\n example diagnostic report from above:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     Start with all 12 numbers and consider only the first bit of each number.\\n     There are more 1 bits (7) than 0 bits (5), so keep only the 7 numbers\\n     with a 1 in the first position: 11110, 10110, 10111, 10101, 11100, 10000,\\n     and 11001. Then, consider the second bit of the 7 remaining numbers:\\n     there are more 0 bits (4) than 1 bits (3), so keep only the 4 numbers\\n     with a 0 in the second position: 10110, 10111, 10101, and 10000. In the\\n     third position, three of the four numbers have a 1, so keep those three:\\n     10110, 10111, and 10101. In the fourth position, two of the three numbers\\n     have a 1, so keep those two: 10110 and 10111. In the fifth position,\\n     there are an equal number of 0 bits and 1 bits (one each). So, to find\\n     the oxygen generator rating, keep the number with a 1 in that position:\\n     10111. As there is only one number left, stop; the oxygen generator\\n     rating is 10111, or 23 in decimal.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(let [[zeros ones] (count-bits (first (matrix/columns test-matrix)))\\n      o2-filter (if (< zeros ones)\\n                  (partial = \\\\1)\\n                  (partial = \\\\0))]\\n  (filterv #(o2-filter (first %)) test-matrix))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [0 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [1 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 3], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [2 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [3 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 2], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [4 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [5], :nextjournal/value [{:path [5 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 1], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [5 4], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [6], :nextjournal/value [{:path [6 0], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 1], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 2], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 3], :nextjournal/value \\\\0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}} {:path [6 4], :nextjournal/value \\\\1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/char?--5425\\\", :fn #function+ (fn [c] (v/html [:span.syntax-string.inspected-value \\\"\\\\\\\\\\\" c]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn o2-filter\\n  \\\"given a vector of bits from the current column, return a function predicate\\nthat returns true only if the row contains proper value in proper column\\\"\\n  [v]\\n  (let [[zeros ones] (count-bits v)\\n        predicate (if (<= zeros ones)\\n                    (partial = \\\\1)\\n                    (partial = \\\\0))]\\n    (fn [col-num row]\\n      (predicate (nth row col-num)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/o2-filter\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn rating\\n  ([m filter-fn]\\n   (rating m filter-fn 0))\\n  ([m filter-fn i]\\n   (let [col (nth (matrix/columns m) i)\\n         f (filter-fn col)\\n         next-m (filter (fn [row] (f i row)) m)]\\n     (if (= 1 (count next-m))\\n       (bin->int (s/join (first next-m)))\\n       (recur next-m filter-fn (inc i))))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/rating\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(rating test-matrix o2-filter )\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Then, to determine the CO2 scrubber rating value from the same example above:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     Start again with all 12 numbers and consider only the first bit of each\\n     number. There are fewer 0 bits (5) than 1 bits (7), so keep only the 5\\n     numbers with a 0 in the first position: 00100, 01111, 00111, 00010, and\\n     01010. Then, consider the second bit of the 5 remaining numbers: there\\n     are fewer 1 bits (2) than 0 bits (3), so keep only the 2 numbers with a 1\\n     in the second position: 01111 and 01010. In the third position, there are\\n     an equal number of 0 bits and 1 bits (one each). So, to find the CO2\\n     scrubber rating, keep the number with a 0 in that position: 01010. As\\n     there is only one number left, stop; the CO2 scrubber rating is 01010, or\\n     10 in decimal.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn co2-filter\\n  \\\"given a vector of bits from the current column, return a function predicate\\nthat returns true only if the row contains proper value in proper column\\\"\\n  [v]\\n  (let [[zeros ones] (count-bits v)\\n        predicate (if (<= zeros ones)\\n                    (partial = \\\\0)\\n                    (partial = \\\\1))]\\n    (fn [col-num row]\\n      (predicate (nth row col-num)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/co2-filter\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(rating test-matrix co2-filter)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Finally, to find the life support rating, multiply the oxygen generator\\n rating (23) by the CO2 scrubber rating (10) to get 230.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn life-support-rating [m]\\n  (* (rating m co2-filter)\\n     (rating m o2-filter)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day03/life-support-rating\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(life-support-rating test-matrix)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 230, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Use the binary numbers in your diagnostic report to calculate the oxygen\\n generator rating and CO2 scrubber rating, then multiply them together. What\\n is the life support rating of the submarine? (Be sure to represent your\\n answer in decimal, not binary.)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(life-support-rating input-matrix)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 4105235, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :xandrews.day03}}, \"src/xandrews/day04.clj\" {:nextjournal/value [{:nextjournal/value \"(ns xandrews.day04\\n  (:require [clojure.java.io :as io]\\n            [clojure.string :as s]\\n            [clojure.core.matrix :as matrix]\\n            [nextjournal.clerk :as clerk]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Day 4: Giant Squid\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def input (s/split-lines (slurp (io/resource \\\"day04.txt\\\"))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [\\\"38,54,68,93,72,12,33,8,98,88,21,91,53,61,26,36,18,80,73,47,3,5,55,92,67,52,25,40,56,95,9,62,30,31,85\\\" {:nextjournal/value {:path [0], :count 289, :offset 100, :remaining 189}, :nextjournal/viewer :elision}], :replace-path [0 0], :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [1], :nextjournal/value \\\"\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [2], :nextjournal/value \\\"57  7  8 38 31\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [3], :nextjournal/value \\\"17 96  5 12 18\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [4], :nextjournal/value \\\"58 45 81 89  4\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [5], :nextjournal/value \\\"73 51 93 32 10\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [6], :nextjournal/value \\\"74 50 26  0 24\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [7], :nextjournal/value \\\"\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [8], :nextjournal/value \\\"79 67 21 84 71\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [9], :nextjournal/value \\\"25 22 19 80 13\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [10], :nextjournal/value \\\"10 63 90 78 33\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [11], :nextjournal/value \\\"93 50 89 58 87\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [12], :nextjournal/value \\\"91  7 45  6 41\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [13], :nextjournal/value \\\"\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [14], :nextjournal/value \\\"66 85  4 91 41\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [15], :nextjournal/value \\\"59 69 16  0 90\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [16], :nextjournal/value \\\"35 13 64 61 93\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [17], :nextjournal/value \\\"11 20 29 67 77\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [18], :nextjournal/value \\\"92 75 58  3 34\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [19], :nextjournal/value \\\"\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:nextjournal/value {:count 601, :offset 20, :path [], :remaining 581}, :nextjournal/viewer :elision}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def numbers-called (mapv #(Integer/parseInt %) (s/split (first input) #\\\",\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 38, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 54, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 68, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 93, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4], :nextjournal/value 72, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6], :nextjournal/value 33, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8], :nextjournal/value 98, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9], :nextjournal/value 88, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [10], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [11], :nextjournal/value 91, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [12], :nextjournal/value 53, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [13], :nextjournal/value 61, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [14], :nextjournal/value 26, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [15], :nextjournal/value 36, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [16], :nextjournal/value 18, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [17], :nextjournal/value 80, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [18], :nextjournal/value 73, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [19], :nextjournal/value 47, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:nextjournal/value {:count 100, :offset 20, :path [], :remaining 80}, :nextjournal/viewer :elision}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" You're already almost 1.5km (almost a mile) below the surface of the ocean,\\n already so deep that you can't see any sunlight. What you can see, however,\\n is a giant squid that has attached itself to the outside of your submarine.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Maybe it wants to play bingo?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Bingo is played on a set of boards each consisting of a 5x5 grid of numbers.\\n Numbers are chosen at random, and the chosen number is marked on all boards\\n on which it appears. (Numbers may not appear on all boards.) If all numbers\\n in any row or any column of a board are marked, that board wins. (Diagonals\\n don't count.)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The submarine has a bingo subsystem to help passengers (currently, you and\\n the giant squid) pass the time. It automatically generates a random order in\\n which to draw numbers and a random set of boards (your puzzle input). For\\n example:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def test-numbers [7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4], :nextjournal/value 11, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5], :nextjournal/value 17, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9], :nextjournal/value 14, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [10], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [11], :nextjournal/value 24, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [12], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [13], :nextjournal/value 16, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [14], :nextjournal/value 13, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [15], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [16], :nextjournal/value 15, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [17], :nextjournal/value 25, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [18], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [19], :nextjournal/value 22, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:nextjournal/value {:count 27, :offset 20, :path [], :remaining 7}, :nextjournal/viewer :elision}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-board-str\\n  \\\"\\n\\n22 13 17 11  0\\n 8  2 23  4 24\\n21  9 14 16  7\\n 6 10  3 18  5\\n 1 12 20 15 19\\n\\n 3 15  0  2 22\\n 9 18 13 17  5\\n19  8  7 25 23\\n20 11 10 24  4\\n14 21 16 12  6\\n\\n14 21 17 24  4\\n10 16 15  9 19\\n18  8 23 26 20\\n22 11 13  6  5\\n 2  0 12  3  7\\n\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"\\\\n\\\\n22 13 17 11  0\\\\n 8  2 23  4 24\\\\n21  9 14 16  7\\\\n 6 10  3 18  5\\\\n 1 12 20 15 19\\\\n\\\\n 3 15  0  2 22\\\\n 9 18 1\\\" {:nextjournal/value {:path [], :count 229, :offset 100, :remaining 129}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn parse-row\\n  [s]\\n  (mapv #(Integer/parseInt %)\\n        (filter not-empty (s/split s #\\\" \\\"))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day04/parse-row\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn parse-boards\\n  [lines]\\n  (loop [boards []\\n         board []\\n         lines lines]\\n    (let [line (first lines)]\\n      (cond\\n        (nil? line)\\n        (conj boards board)\\n\\n        (and (empty? line) (not-empty board))\\n        (recur (conj boards board) [] (next lines))\\n\\n        (empty? line)\\n        (recur boards board (next lines))\\n\\n        :else\\n        (recur boards\\n               (conj board (parse-row line))\\n               (next lines))))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day04/parse-boards\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-boards\\n  (parse-boards (s/split-lines test-board-str)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value 22, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 1], :nextjournal/value 13, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 2], :nextjournal/value 17, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 3], :nextjournal/value 11, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 2], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 3], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 4], :nextjournal/value 24, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 2], :nextjournal/value 14, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 3], :nextjournal/value 16, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 4], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 3], :nextjournal/value [{:path [0 3 0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 1], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 2], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 3], :nextjournal/value 18, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 4], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 4], :nextjournal/value [{:path [0 4 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 1], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 2], :nextjournal/value 20, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 3], :nextjournal/value 15, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 4], :nextjournal/value 19, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 1], :nextjournal/value 15, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 3], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 4], :nextjournal/value 22, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 1], :nextjournal/value 18, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 2], :nextjournal/value 13, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 3], :nextjournal/value 17, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 4], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 2], :nextjournal/value [{:path [1 2 0], :nextjournal/value 19, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 1], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 2], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 3], :nextjournal/value 25, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 4], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 3], :nextjournal/value [{:path [1 3 0], :nextjournal/value 20, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 1], :nextjournal/value 11, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 2], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 3], :nextjournal/value 24, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 4], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 4], :nextjournal/value [{:path [1 4 0], :nextjournal/value 14, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 1], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 2], :nextjournal/value 16, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 3], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 4], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value [{:path [2 0 0], :nextjournal/value 14, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 1], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 2], :nextjournal/value 17, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 3], :nextjournal/value 24, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 4], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 1], :nextjournal/value [{:path [2 1 0], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 1], :nextjournal/value 16, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 2], :nextjournal/value 15, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 3], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 4], :nextjournal/value 19, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 2], :nextjournal/value [{:path [2 2 0], :nextjournal/value 18, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 1], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 2], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 3], :nextjournal/value 26, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 4], :nextjournal/value 20, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 3], :nextjournal/value [{:path [2 3 0], :nextjournal/value 22, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 1], :nextjournal/value 11, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 2], :nextjournal/value 13, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 3], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 4], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 4], :nextjournal/value [{:path [2 4 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 2], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 3], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 4], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def a-board (first test-boards))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 22, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 13, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2], :nextjournal/value 17, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3], :nextjournal/value 11, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4], :nextjournal/value 24, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2], :nextjournal/value 14, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3], :nextjournal/value 16, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 2], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 3], :nextjournal/value 18, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 4], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 2], :nextjournal/value 20, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 3], :nextjournal/value 15, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 4], :nextjournal/value 19, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(clerk/table a-board)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [:rows], :nextjournal/value {:rows {:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 22, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 13, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2], :nextjournal/value 17, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3], :nextjournal/value 11, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4], :nextjournal/value 24, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2], :nextjournal/value 14, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3], :nextjournal/value 16, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 2], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 3], :nextjournal/value 18, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 4], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 2], :nextjournal/value 20, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 3], :nextjournal/value 15, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 4], :nextjournal/value 19, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}}, :nextjournal/viewer {:pred #function+ \\\"nextjournal.clerk.viewer/fn--7563\\\", :name :table, :fn #function+ v/table-viewer, :fetch-fn \\\"nextjournal.clerk.viewer/fn--7566\\\"}, :replace-path [0]}\", :width :wide, :viewer :table}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(clerk/table (matrix/eq a-board 7))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [:rows], :nextjournal/value {:rows {:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}}, :nextjournal/viewer {:pred #function+ \\\"nextjournal.clerk.viewer/fn--7563\\\", :name :table, :fn #function+ v/table-viewer, :fetch-fn \\\"nextjournal.clerk.viewer/fn--7566\\\"}, :replace-path [0]}\", :width :wide, :viewer :table}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(clerk/table\\n (matrix/add\\n  (matrix/eq a-board 7)\\n  (matrix/eq a-board 4)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [:rows], :nextjournal/value {:rows {:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}}, :nextjournal/viewer {:pred #function+ \\\"nextjournal.clerk.viewer/fn--7563\\\", :name :table, :fn #function+ v/table-viewer, :fetch-fn \\\"nextjournal.clerk.viewer/fn--7566\\\"}, :replace-path [0]}\", :width :wide, :viewer :table}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(matrix/eq test-boards 7)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 3], :nextjournal/value [{:path [0 3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 4], :nextjournal/value [{:path [0 4 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 2], :nextjournal/value [{:path [1 2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 2], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 3], :nextjournal/value [{:path [1 3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 4], :nextjournal/value [{:path [1 4 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value [{:path [2 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 1], :nextjournal/value [{:path [2 1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 2], :nextjournal/value [{:path [2 2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 3], :nextjournal/value [{:path [2 3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 4], :nextjournal/value [{:path [2 4 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" After the first five numbers are drawn (7, 4, 9, 5, and 11), there are no\\n winners, but the boards are marked as follows (shown here adjacent to each\\n other to save space):\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     22 13 17 11  0         3 15  0  2 22        14 21 17 24  4\\n      8  2 23  4 24         9 18 13 17  5        10 16 15  9 19\\n     21  9 14 16  7        19  8  7 25 23        18  8 23 26 20\\n      6 10  3 18  5        20 11 10 24  4        22 11 13  6  5\\n      1 12 20 15 19        14 21 16 12  6         2  0 12  3  7\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" After the next six numbers are drawn (17, 23, 2, 0, 14, and 21), there are\\n still no winners:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     22 13 17 11  0         3 15  0  2 22        14 21 17 24  4\\n      8  2 23  4 24         9 18 13 17  5        10 16 15  9 19\\n     21  9 14 16  7        19  8  7 25 23        18  8 23 26 20\\n      6 10  3 18  5        20 11 10 24  4        22 11 13  6  5\\n      1 12 20 15 19        14 21 16 12  6         2  0 12  3  7\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Finally, 24 is drawn:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     22 13 17 11  0         3 15  0  2 22        14 21 17 24  4\\n      8  2 23  4 24         9 18 13 17  5        10 16 15  9 19\\n     21  9 14 16  7        19  8  7 25 23        18  8 23 26 20\\n      6 10  3 18  5        20 11 10 24  4        22 11 13  6  5\\n      1 12 20 15 19        14 21 16 12  6         2  0 12  3  7\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" At this point, the third board wins because it has at least one complete row\\n or column of marked numbers (in this case, the entire top row is marked: 14\\n 21 17 24 4).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Each board has a score which is 0 by default, 1 if the number has been called.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def win-row [1 1 1 1 1])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn winner?\\n  [score]\\n  (boolean\\n   (or\\n    (some #(= win-row %) (matrix/rows score))\\n    (some #(= win-row %) (matrix/columns score)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day04/winner?\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn call-number\\n  \\\"Returns the new scores matrix after applying the called number\\\"\\n  [boards scores number]\\n  (matrix/add scores\\n              (matrix/eq boards number)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day04/call-number\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" scores can be initialized with scalar 0\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(call-number test-boards 0 7)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 3], :nextjournal/value [{:path [0 3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 4], :nextjournal/value [{:path [0 4 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 2], :nextjournal/value [{:path [1 2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 2], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 3], :nextjournal/value [{:path [1 3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 4], :nextjournal/value [{:path [1 4 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value [{:path [2 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 1], :nextjournal/value [{:path [2 1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 2], :nextjournal/value [{:path [2 2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 2 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 3], :nextjournal/value [{:path [2 3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 3 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 4], :nextjournal/value [{:path [2 4 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 4 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def winner-stats\\n  (loop [scores (matrix/mul test-boards 0)\\n         numbers test-numbers\\n         prev-number nil]\\n    (let [number (first numbers)\\n          winners (mapv winner? scores)\\n          winner-idx (.indexOf winners true)]\\n      (if (< 0 winner-idx)\\n        [(nth test-boards winner-idx) (nth scores winner-idx) prev-number]\\n        (recur (call-number test-boards scores number)\\n               (rest numbers)\\n               number)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value 14, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 1], :nextjournal/value 21, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 2], :nextjournal/value 17, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 3], :nextjournal/value 24, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 4], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 1], :nextjournal/value 16, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 2], :nextjournal/value 15, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 3], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 4], :nextjournal/value 19, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 2], :nextjournal/value [{:path [0 2 0], :nextjournal/value 18, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 1], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 2], :nextjournal/value 23, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 3], :nextjournal/value 26, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 2 4], :nextjournal/value 20, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 3], :nextjournal/value [{:path [0 3 0], :nextjournal/value 22, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 1], :nextjournal/value 11, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 2], :nextjournal/value 13, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 3], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 3 4], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 4], :nextjournal/value [{:path [0 4 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 2], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 3], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 4 4], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 2], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 3], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 3], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 2], :nextjournal/value [{:path [1 2 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 2], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 2 4], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 3], :nextjournal/value [{:path [1 3 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 3 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 4], :nextjournal/value [{:path [1 4 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 2], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 4 4], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [2], :nextjournal/value 24, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" The score of the winning board can now be calculated. Start by finding the\\n sum of all unmarked numbers on that board; in this case, the sum is 188.\\n Then, multiply that sum by the number that was just called when the board\\n won, 24, to get the final score, 188 * 24 = 4512.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" We get unmarked numbers from the score matrix.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def unmarked-number-sum\\n  (matrix/esum\\n   (matrix/mul\\n    (nth winner-stats 0)\\n    (matrix/eq (nth winner-stats 1) 0))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 188, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def final-score\\n  (* unmarked-number-sum (nth winner-stats 2)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 4512, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn winner\\n  [boards numbers]\\n  (loop [scores (matrix/mul boards 0)\\n         numbers numbers\\n         prev-number nil]\\n    (let [number (first numbers)\\n          winners (mapv winner? scores)\\n          winner-idx (.indexOf winners true)]\\n      (if (< 0 winner-idx)\\n        [(nth boards winner-idx) (nth scores winner-idx) prev-number]\\n        (recur (call-number boards scores number)\\n               (rest numbers)\\n               number)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day04/winner\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn winning-board-score [board score number]\\n  (* number\\n     (matrix/esum\\n      (matrix/mul board\\n                  (matrix/eq score 0)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day04/winning-board-score\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(apply winning-board-score (winner test-boards test-numbers))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 4512, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" To guarantee victory against the giant squid, figure out which board will win\\n first. What will your final score be if you choose that board?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(apply winning-board-score\\n       (winner (parse-boards (rest input)) numbers-called))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 58838, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Part Two\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" On the other hand, it might be wise to try a different strategy: let the\\n giant squid win.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" You aren't sure how many bingo boards a giant squid could play at once, so\\n rather than waste time counting its arms, the safe thing to do is to figure\\n out which board will win last and choose that one. That way, no matter which\\n boards it picks, it will win for sure.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" In the above example, the second board is the last to win, which happens\\n after 13 is eventually called and its middle column is completely marked. If\\n you were to keep playing until this point, the second board would have a sum\\n of unmarked numbers equal to 148 for a final score of 148 * 13 = 1924.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Figure out which board will win last. Once it wins, what would its final\\n score be?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn last-to-win\\n  [boards numbers]\\n  (loop [scores (matrix/mul boards 0)\\n         numbers numbers\\n         prev-number nil\\n         last-idx -1]\\n    (let [number (first numbers)\\n          winners (mapv winner? scores)\\n          idx (.indexOf winners false)]\\n      (if (every? true? winners)\\n        [(nth boards last-idx) (nth scores last-idx) prev-number]\\n        (recur (call-number boards scores number)\\n               (rest numbers)\\n               number\\n               (if (<= 0 idx) idx last-idx))))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day04/last-to-win\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(apply winning-board-score\\n       (last-to-win test-boards test-numbers))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 1924, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(apply winning-board-score\\n       (last-to-win (parse-boards (rest input)) numbers-called))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 6256, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :xandrews.day04}}, \"src/xandrews/day05.clj\" {:nextjournal/value [{:nextjournal/value \"(ns xandrews.day05\\n  (:require [clojure.java.io :as io]\\n            [clojure.string :as s]\\n            [nextjournal.clerk :as clerk]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Day 5: Hydrothermal Venture\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" You come across a field of hydrothermal vents on the ocean floor! These vents\\n constantly produce large, opaque clouds, so it would be best to avoid them if\\n possible.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" They tend to form in lines; the submarine helpfully produces a list of nearby\\n lines of vents (your puzzle input) for you to review. For example:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def test-input\\n  \\\"0,9 -> 5,9\\n8,0 -> 0,8\\n9,4 -> 3,4\\n2,2 -> 2,1\\n7,0 -> 7,4\\n6,4 -> 2,0\\n0,9 -> 2,9\\n3,4 -> 1,4\\n0,0 -> 8,8\\n5,5 -> 8,2\\n\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"0,9 -> 5,9\\\\n8,0 -> 0,8\\\\n9,4 -> 3,4\\\\n2,2 -> 2,1\\\\n7,0 -> 7,4\\\\n6,4 -> 2,0\\\\n0,9 -> 2,9\\\\n3,4 -> 1,4\\\\n0,0 -> 8,8\\\\n5\\\" {:nextjournal/value {:path [], :count 110, :offset 100, :remaining 10}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Each line of vents is given as a line segment in the format x1,y1 -> x2,y2\\n where x1,y1 are the coordinates of one end the line segment and x2,y2 are the\\n coordinates of the other end. These line segments include the points at both\\n ends. In other words:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     An entry like 1,1 -> 1,3 covers points 1,1, 1,2, and 1,3.\\n     An entry like 9,7 -> 7,7 covers points 9,7, 8,7, and 7,7.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(re-matches #\\\"(\\\\d+),(\\\\d+) -> (\\\\d+),(\\\\d+)\\\" \\\"0,9 -> 5,9\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value \\\"0,9 -> 5,9\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [1], :nextjournal/value \\\"0\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [2], :nextjournal/value \\\"9\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [3], :nextjournal/value \\\"5\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}} {:path [4], :nextjournal/value \\\"9\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn parse-coordinates\\n  [input]\\n  (->> input\\n       s/split-lines\\n       (map (fn [line]\\n              (re-matches #\\\"(\\\\d+),(\\\\d+) -> (\\\\d+),(\\\\d+)\\\" line)))\\n       (map (fn [[_ x1 y1 x2 y2]]\\n              [[(Integer/parseInt x1) (Integer/parseInt y1)]\\n               [(Integer/parseInt x2) (Integer/parseInt y2)]]))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day05/parse-coordinates\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-coords\\n  (parse-coordinates test-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value [{:path [0 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 0 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [0 1], :nextjournal/value [{:path [0 1 0], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value [{:path [1 0 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1 1], :nextjournal/value [{:path [1 1 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1 1], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value [{:path [2 0 0], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 0 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2 1], :nextjournal/value [{:path [2 1 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value [{:path [3 0 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 0 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [3 1], :nextjournal/value [{:path [3 1 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value [{:path [4 0 0], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [4 1], :nextjournal/value [{:path [4 1 0], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [5], :nextjournal/value [{:path [5 0], :nextjournal/value [{:path [5 0 0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5 0 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [5 1], :nextjournal/value [{:path [5 1 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5 1 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [6], :nextjournal/value [{:path [6 0], :nextjournal/value [{:path [6 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6 0 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [6 1], :nextjournal/value [{:path [6 1 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6 1 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [7], :nextjournal/value [{:path [7 0], :nextjournal/value [{:path [7 0 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7 0 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [7 1], :nextjournal/value [{:path [7 1 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7 1 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [8], :nextjournal/value [{:path [8 0], :nextjournal/value [{:path [8 0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8 0 1], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [8 1], :nextjournal/value [{:path [8 1 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8 1 1], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}} {:path [9], :nextjournal/value [{:path [9 0], :nextjournal/value [{:path [9 0 0], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9 0 1], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [9 1], :nextjournal/value [{:path [9 1 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9 1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\"]\\\" \\\")\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" For now, only consider horizontal and vertical lines: lines where either x1 =\\n x2 or y1 = y2.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn is-h-or-v? [line]\\n  (let [[[x1 y1] [x2 y2]] line]\\n    (if (or (= x1 x2)\\n            (= y1 y2))\\n      true\\n      false)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day05/is-h-or-v?\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(is-h-or-v? (nth test-coords 0))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value true, :nextjournal/viewer {:pred #function+ \\\"clojure.core/boolean?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-bool.inspected-value (str x)]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(is-h-or-v? (nth test-coords 0))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value true, :nextjournal/viewer {:pred #function+ \\\"clojure.core/boolean?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-bool.inspected-value (str x)]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" So, the horizontal and vertical lines from the above list would produce the\\n following diagram:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     .......1..\\n     ..1....1..\\n     ..1....1..\\n     .......1..\\n     .112111211\\n     ..........\\n     ..........\\n     ..........\\n     ..........\\n     222111....\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn line->points\\n  [[[x1 y1] [x2 y2]]]\\n\\n  (for [x (range (min x1 x2) (inc (max x1 x2)))\\n        y (range (min y1 y2) (inc (max y1 y2)))]\\n   [x y]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day05/line->points\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"     An entry like 1,1 -> 1,3 covers points 1,1, 1,2, and 1,3.\\n     An entry like 9,7 -> 7,7 covers points 9,7, 8,7, and 7,7.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(line->points [[1 1] [1 3]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\")\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(line->points [[9 7] [7 7]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\")\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" In this diagram, the top left corner is 0,0 and the bottom right corner is\\n 9,9. Each position is shown as the number of lines which cover that point or\\n . if no line covers that point. The top-left pair of 1s, for example, comes\\n from 2,2 -> 2,1; the very bottom row is formed by the overlapping lines 0,9\\n -> 5,9 and 0,9 -> 2,9.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn overlapping-points\\n  [input]\\n  (->> input\\n       parse-coordinates\\n       (filter is-h-or-v?)\\n       (mapcat line->points)\\n       (reduce (fn [m point]\\n                 (let [num-points (get m point 0)]\\n                   (assoc m point (inc num-points))))\\n               {})\\n       (vals)\\n       (filter (partial < 1))\\n       count))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day05/overlapping-points\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(overlapping-points test-input)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" To avoid the most dangerous areas, you need to determine the number of points\\n where at least two lines overlap. In the above example, this is anywhere in\\n the diagram with a 2 or larger - a total of 5 points.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Consider only horizontal and vertical lines. At how many points do at least\\n two lines overlap?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def input (slurp (io/resource \\\"day05.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"456,846 -> 221,846\\\\n980,926 -> 73,19\\\\n682,930 -> 562,930\\\\n766,592 -> 274,100\\\\n247,685 -> 247,21\\\\n106,800 \\\" {:nextjournal/value {:path [], :count 9268, :offset 100, :remaining 9168}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(overlapping-points input)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 5280, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Unfortunately, considering only horizontal and vertical lines doesn't give\\n you the full picture; you need to also consider diagonal lines.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Because of the limits of the hydrothermal vent mapping system, the lines in\\n your list will only ever be horizontal, vertical, or a diagonal line at\\n exactly 45 degrees. In other words:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     An entry like 1,1 -> 3,3 covers points 1,1, 2,2, and 3,3.\\n     An entry like 9,7 -> 7,9 covers points 9,7, 8,8, and 7,9.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Considering all lines from the above example would now produce the following\\n diagram:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     1.1....11.\\n     .111...2..\\n     ..2.1.111.\\n     ...1.2.2..\\n     .112313211\\n     ...1.2....\\n     ..1...1...\\n     .1.....1..\\n     1.......1.\\n     222111....\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" You still need to determine the number of points where at least two lines\\n overlap. In the above example, this is still anywhere in the diagram with a 2\\n or larger - now a total of 12 points.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Consider all of the lines. At how many points do at least two lines overlap?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn line->points-diag\\n  [[[x1 y1] [x2 y2]]]\\n  (let [f (fn [a b]\\n            (if (< a b) inc dec))\\n        range (fn [a b]\\n                (if (= a b)\\n                  (repeat a)\\n                  (loop [n a\\n                         v []]\\n                    (if (= n b)\\n                      (conj v n)\\n                      (recur ((f a b) n) (conj v n))))))]\\n    (map vector (range x1 x2) (range y1 y2))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day05/line->points-diag\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(line->points-diag [[1 1] [3 3]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\")\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(line->points-diag [[9 7] [7 9]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\")\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(line->points-diag [[1 1] [1 3]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\")\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(line->points-diag [[9 7] [7 7]])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 9, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\" \\\")\\\")}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens nil}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn overlapping-points-incl-diag\\n  [input]\\n  (->> input\\n       parse-coordinates\\n       (mapcat line->points-diag)\\n       (reduce (fn [m point]\\n                 (let [num-points (get m point 0)]\\n                   (assoc m point (inc num-points))))\\n               {})\\n       (vals)\\n       (filter (partial < 1))\\n       count))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day05/overlapping-points-incl-diag\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(overlapping-points-incl-diag test-input)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(overlapping-points-incl-diag input)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 16716, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :xandrews.day05}}, \"src/xandrews/day06.clj\" {:nextjournal/value [{:nextjournal/value \"(ns xandrews.day06\\n  (:require\\n   [clojure.java.io :as io]\\n   [clojure.string :as s]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Day 6: Lanternfish ---\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The sea floor is getting steeper. Maybe the sleigh keys got carried this way?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A massive school of glowing lanternfish swims past. They must spawn quickly\\n to reach such large numbers - maybe exponentially quickly? You should model\\n their growth rate to be sure.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Although you know nothing about this specific species of lanternfish, you\\n make some guesses about their attributes. Surely, each lanternfish creates a\\n new lanternfish once every 7 days.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" However, this process isn't necessarily synchronized between every\\n lanternfish - one lanternfish might have 2 days left until it creates another\\n lanternfish, while another might have 4. So, you can model each fish as a\\n single number that represents the number of days until it creates a new\\n lanternfish.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Furthermore, you reason, a new lanternfish would surely need slightly longer\\n before it's capable of producing more lanternfish: two more days for its\\n first cycle.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" So, suppose you have a lanternfish with an internal timer value of 3:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     After one day, its internal timer would become 2.\\n     After another day, its internal timer would become 1.\\n     After another day, its internal timer would become 0.\\n     After another day, its internal timer would reset to 6, and it would create a new lanternfish with an internal timer of 8.\\n     After another day, the first lanternfish would have an internal timer of 5, and the second lanternfish would have an internal timer of 7.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A lanternfish that creates a new fish resets its timer to 6, not 7 (because 0\\n is included as a valid timer value). The new lanternfish starts with an\\n internal timer of 8 and does not start counting down until the next day.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Realizing what you're trying to do, the submarine automatically produces a\\n list of the ages of several hundred nearby lanternfish (your puzzle input).\\n For example, suppose you were given the following list:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" 3,4,3,1,2\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" This list means that the first fish has an internal timer of 3, the second\\n fish has an internal timer of 4, and so on until the fifth fish, which has an\\n internal timer of 2. Simulating these fish over several days would proceed as\\n follows:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     Initial state: 3,4,3,1,2\\n     After  1 day:  2,3,2,0,1\\n     After  2 days: 1,2,1,6,0,8\\n     After  3 days: 0,1,0,5,6,7,8\\n     After  4 days: 6,0,6,4,5,6,7,8,8\\n     After  5 days: 5,6,5,3,4,5,6,7,7,8\\n     After  6 days: 4,5,4,2,3,4,5,6,6,7\\n     After  7 days: 3,4,3,1,2,3,4,5,5,6\\n     After  8 days: 2,3,2,0,1,2,3,4,4,5\\n     After  9 days: 1,2,1,6,0,1,2,3,3,4,8\\n     After 10 days: 0,1,0,5,6,0,1,2,2,3,7,8\\n     After 11 days: 6,0,6,4,5,6,0,1,1,2,6,7,8,8,8\\n     After 12 days: 5,6,5,3,4,5,6,0,0,1,5,6,7,7,7,8,8\\n     After 13 days: 4,5,4,2,3,4,5,6,6,0,4,5,6,6,6,7,7,8,8\\n     After 14 days: 3,4,3,1,2,3,4,5,5,6,3,4,5,5,5,6,6,7,7,8\\n     After 15 days: 2,3,2,0,1,2,3,4,4,5,2,3,4,4,4,5,5,6,6,7\\n     After 16 days: 1,2,1,6,0,1,2,3,3,4,1,2,3,3,3,4,4,5,5,6,8\\n     After 17 days: 0,1,0,5,6,0,1,2,2,3,0,1,2,2,2,3,3,4,4,5,7,8\\n     After 18 days: 6,0,6,4,5,6,0,1,1,2,6,0,1,1,1,2,2,3,3,4,6,7,8,8,8,8\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" going to need a way to represent these that doesn't require an ever-growing list...\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn init-state\\n  [s]\\n  (reduce (fn [m n]\\n            (let [age (Integer/parseInt (s/trim n))\\n                  count (get m age 0)]\\n              (assoc m age (inc count))))\\n          {}\\n          (s/split s #\\\",\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day06/init-state\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(init-state \\\"3,4,3,1,2\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Each day, a 0 becomes a 6 and adds a new 8 to the end of the list, while each\\n other number decreases by 1 if it was present at the start of the day.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn safe-adder [n]\\n  (fn [x]\\n    (if (nil? x)\\n      n\\n      (+ n x))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day06/safe-adder\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn tick\\n  [ages]\\n  (reduce-kv\\n   (fn [m k v]\\n     (if (zero? k)\\n       (-> m\\n           (assoc 8 v)\\n           (update 6 (safe-adder v)))\\n       (update m (dec k) (safe-adder v))))\\n   {}\\n   ages))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day06/tick\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(->\\n (init-state \\\"3,4,3,1,2\\\")\\n tick\\n tick)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn simulate-days\\n  [ages days]\\n  (if (zero? days)\\n    ages\\n    (recur (tick ages) (dec days))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day06/simulate-days\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(simulate-days (init-state \\\"3,4,3,1,2\\\") 2)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" In this example, after 18 days, there are a total of 26 fish. After 80 days,\\n there would be a total of 5934.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(simulate-days (init-state \\\"3,4,3,1,2\\\") 18)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value [{:path [0 0], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [0 1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [1], :nextjournal/value [{:path [1 0], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1 1], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [2], :nextjournal/value [{:path [2 0], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2 1], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [3], :nextjournal/value [{:path [3 0], :nextjournal/value 3, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [4], :nextjournal/value [{:path [4 0], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4 1], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [5], :nextjournal/value [{:path [5 0], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [6], :nextjournal/value [{:path [6 0], :nextjournal/value 6, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6 1], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [7], :nextjournal/value [{:path [7 0], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7 1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}} {:path [8], :nextjournal/value [{:path [8 0], :nextjournal/value 8, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8 1], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map-entry?\\\", :name :map-entry, :fn #function+ (fn [xs opts] (v/html (into [:<>] (comp (v/inspect-children opts) (interpose \\\" \\\")) xs))), :fetch-opts {:n 2}}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/map?--5429\\\", :name :map, :fn #function+ v/map-viewer, :fetch-opts {:n 10}, :closing-parens (\\\"}\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(reduce + (vals\\n           (simulate-days (init-state \\\"3,4,3,1,2\\\") 18)\\n           ))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 26, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn count-fish\\n  [input days]\\n  (reduce + (vals (simulate-days (init-state input) days))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day06/count-fish\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(count-fish \\\"3,4,3,1,2\\\" 80)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 5934, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Find a way to simulate lanternfish. How many lanternfish would there be after 80 days?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def input (slurp (io/resource \\\"day06.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"2,5,3,4,4,5,3,2,3,3,2,2,4,2,5,4,1,1,4,4,5,1,2,1,5,2,1,5,1,1,1,2,4,3,3,1,4,2,3,4,5,1,2,5,1,2,2,5,2,4,\\\" {:nextjournal/value {:path [], :count 600, :offset 100, :remaining 500}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(count-fish input 80)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 345387, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Part Two\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Suppose the lanternfish live forever and have unlimited food and space. Would\\n they take over the entire ocean?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" After 256 days in the example above, there would be a total of 26984457539\\n lanternfish!\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" How many lanternfish would there be after 256 days?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(count-fish input 256)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 1574445493136, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :xandrews.day06}}, \"src/xandrews/day07.clj\" {:nextjournal/value [{:nextjournal/value \"(ns xandrews.day07\\n  (:require\\n   [clojure.java.io :as io]\\n   [clojure.string :as s]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Day 7: The Treachery of Whales\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" A giant whale has decided your submarine is its next meal, and it's much\\n faster than you are. There's nowhere to run!\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Suddenly, a swarm of crabs (each in its own tiny submarine - it's too deep\\n for them otherwise) zooms in to rescue you! They seem to be preparing to\\n blast a hole in the ocean floor; sensors indicate a massive underground cave\\n system just beyond where they're aiming!\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The crab submarines all need to be aligned before they'll have enough power\\n to blast a large enough hole for your submarine to get through. However, it\\n doesn't look like they'll be aligned before the whale catches you! Maybe you\\n can help?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" There's one major catch - crab submarines can only move horizontally.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" You quickly make a list of the horizontal position of each crab (your puzzle\\n input). Crab submarines have limited fuel, so you need to find a way to make\\n all of their horizontal positions match while requiring them to spend as\\n little fuel as possible.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" For example, consider the following horizontal positions:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     16,1,2,0,4,2,7,1,2,14\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def test-input \\\"16,1,2,0,4,2,7,1,2,14\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"16,1,2,0,4,2,7,1,2,14\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/string?--5427\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" This means there's a crab with horizontal position 16, a crab with horizontal\\n position 1, and so on.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn positions\\n  [in]\\n  (as-> in x\\n      (s/split x #\\\",\\\")\\n      (map #(Integer/parseInt %) x)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/positions\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(positions test-input)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 16, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4], :nextjournal/value 4, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6], :nextjournal/value 7, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7], :nextjournal/value 1, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9], :nextjournal/value 14, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/sequential?\\\", :fn #function+ (partial v/coll-viewer {:open \\\"(\\\", :close \\\")\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\")\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Each change of 1 step in horizontal position of a single crab costs 1 fuel.\\n You could choose any horizontal position to align them all on, but the one\\n that costs the least fuel is horizontal position 2:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     Move from 16 to 2: 14 fuel\\n     Move from 1 to 2: 1 fuel\\n     Move from 2 to 2: 0 fuel\\n     Move from 0 to 2: 2 fuel\\n     Move from 4 to 2: 2 fuel\\n     Move from 2 to 2: 0 fuel\\n     Move from 7 to 2: 5 fuel\\n     Move from 1 to 2: 1 fuel\\n     Move from 2 to 2: 0 fuel\\n     Move from 14 to 2: 12 fuel\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn default-crab-cost\\n  [a b]\\n  (if (> a b)\\n    (- a b)\\n    (- b a)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/default-crab-cost\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn alignment-costs\\n  ([positions]\\n   (alignment-costs positions default-crab-cost))\\n  ([positions cost-fn]\\n   (reduce (fn [v p]\\n             (assoc v p\\n                    (reduce (fn [cost position]\\n                              (+ cost\\n                                 (cost-fn position p)))\\n                            0\\n                            positions)))\\n           []\\n           (range (apply min positions) (inc (apply max positions))))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/alignment-costs\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-costs\\n  (alignment-costs (positions test-input)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [{:path [0], :nextjournal/value 49, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [1], :nextjournal/value 41, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [2], :nextjournal/value 37, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [3], :nextjournal/value 39, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [4], :nextjournal/value 41, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [5], :nextjournal/value 45, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [6], :nextjournal/value 49, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [7], :nextjournal/value 53, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [8], :nextjournal/value 59, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [9], :nextjournal/value 65, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [10], :nextjournal/value 71, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [11], :nextjournal/value 77, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [12], :nextjournal/value 83, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [13], :nextjournal/value 89, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [14], :nextjournal/value 95, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [15], :nextjournal/value 103, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}} {:path [16], :nextjournal/value 111, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}], :nextjournal/viewer {:pred #function+ \\\"clojure.core/vector?--5431\\\", :fn #function+ (partial v/coll-viewer {:open \\\"[\\\", :close \\\"]\\\"}), :fetch-opts {:n 20}, :closing-parens (\\\"]\\\")}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" This costs a total of 37 fuel. This is the cheapest possible outcome; more\\n expensive outcomes include aligning at position 1 (41 fuel), position 3 (39\\n fuel), or position 10 (71 fuel).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn min-index\\n  [v]\\n  (.indexOf v (apply min v)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/min-index\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn cheapest-position\\n  [input]\\n  (-> input\\n      positions\\n      alignment-costs\\n      min-index))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/cheapest-position\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(cheapest-position test-input)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 2, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Determine the horizontal position that the crabs can align to using the least\\n fuel possible. How much fuel must they spend to align to that position?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn least-fuel\\n  [input]\\n  (->> input\\n      positions\\n      alignment-costs\\n      (apply min)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/least-fuel\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(least-fuel test-input)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 37, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(least-fuel\\n (s/trim (slurp (io/resource \\\"day07.txt\\\"))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 351901, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Part Two ---\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The crabs don't seem interested in your proposed solution. Perhaps you\\n misunderstand crab engineering?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" As it turns out, crab submarine engines don't burn fuel at a constant rate.\\n Instead, each change of 1 step in horizontal position costs 1 more unit of\\n fuel than the last: the first step costs 1, the second step costs 2, the\\n third step costs 3, and so on.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn arithmetic-sum\\n  [n]\\n  (* (/ n 2)\\n   (+ 2 (dec n))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/arithmetic-sum\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn crab-cost\\n  [a b]\\n  (let [x (min a b)\\n        y (max a b)\\n        n ( - y x)]\\n    (arithmetic-sum n)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/crab-cost\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(crab-cost 1 0)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 1N, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(crab-cost 1 1)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 0, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(crab-cost 1 2)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 1N, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(crab-cost 1 5)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(crab-cost 5 16)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 66N, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(crab-cost 16 5)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 66N, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" As each crab moves, moving further becomes more expensive. This changes the\\n best horizontal position to align them all on; in the example above, this\\n becomes 5:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     Move from 16 to 5: 66 fuel\\n     Move from 1 to 5: 10 fuel\\n     Move from 2 to 5: 6 fuel\\n     Move from 0 to 5: 15 fuel\\n     Move from 4 to 5: 1 fuel\\n     Move from 2 to 5: 6 fuel\\n     Move from 7 to 5: 3 fuel\\n     Move from 1 to 5: 10 fuel\\n     Move from 2 to 5: 6 fuel\\n     Move from 14 to 5: 45 fuel\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" This costs a total of 168 fuel. This is the new cheapest possible outcome;\\n the old alignment position (2) now costs 206 fuel instead.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn least-fuel-v2\\n  [input cost-fn]\\n  (as-> input x\\n      (positions x)\\n      (alignment-costs x crab-cost)\\n      (apply min x)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"xandrews.day07/least-fuel-v2\\\", :nextjournal/viewer {:pred #function+ \\\"clojure.core/fn?\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(least-fuel-v2 test-input crab-cost)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 168N, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Determine the horizontal position that the crabs can align to using the least\\n fuel possible so they can make you an escape route! How much fuel must they\\n spend to align to that position?\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(least-fuel-v2\\n (s/trim (slurp (io/resource \\\"day07.txt\\\")))\\n crab-cost)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 101079875N, :nextjournal/viewer {:pred #function+ \\\"clojure.core/number?\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :xandrews.day07}}, \"src/xandrews/day08.clj\" {:nextjournal/value [{:nextjournal/value \"(ns xandrews.day08)\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"clojure.core/nil?\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" # Day 8: Seven Segment Search\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" You barely reach the safety of the cave when the whale smashes into the cave\\n mouth, collapsing it. Sensors indicate another exit to this cave at a much\\n greater depth, so you have no choice but to press on.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" As your submarine slowly makes its way through the cave system, you notice\\n that the four-digit seven-segment displays in your submarine are\\n malfunctioning; they must have been damaged during the escape. You'll be in a\\n lot of trouble without them, so you'd better figure out what's wrong.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Each digit of a seven-segment display is rendered by turning on or off any of\\n seven segments named a through g:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"       0:      1:      2:      3:      4:\\n      aaaa    ....    aaaa    aaaa    ....\\n     b    c  .    c  .    c  .    c  b    c\\n     b    c  .    c  .    c  .    c  b    c\\n      ....    ....    dddd    dddd    dddd\\n     e    f  .    f  e    .  .    f  .    f\\n     e    f  .    f  e    .  .    f  .    f\\n      gggg    ....    gggg    gggg    ....\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"       5:      6:      7:      8:      9:\\n      aaaa    aaaa    aaaa    aaaa    aaaa\\n     b    .  b    .  .    c  b    c  b    c\\n     b    .  b    .  .    c  b    c  b    c\\n      dddd    dddd    ....    dddd    dddd\\n     .    f  e    f  .    f  e    f  .    f\\n     .    f  e    f  .    f  e    f  .    f\\n      gggg    gggg    ....    gggg    gggg\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" So, to render a 1, only segments c and f would be turned on; the rest would\\n be off. To render a 7, only segments a, c, and f would be turned on.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" The problem is that the signals which control the segments have been mixed up\\n on each display. The submarine is still trying to display numbers by\\n producing output on signal wires a through g, but those wires are connected\\n to segments randomly. Worse, the wire/segment connections are mixed up\\n separately for each four-digit display! (All of the digits within a display\\n use the same connections, though.)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" So, you might know that only signal wires b and g are turned on, but that\\n doesn't mean segments b and g are turned on: the only digit that uses two\\n segments is 1, so it must mean segments c and f are meant to be on. With just\\n that information, you still can't tell which wire (b/g) goes to which segment\\n (c/f). For that, you'll need to collect more information.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" For each display, you watch the changing signals for a while, make a note of\\n all ten unique signal patterns you see, and then write down a single four\\n digit output value (your puzzle input). Using the signal patterns, you should\\n be able to work out which pattern corresponds to which digit.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" For example, here is what you might see in a single entry in your notes:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab |\\n     cdfeb fcadb cdfeb cdbaf\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" (The entry is wrapped here to two lines so it fits; in your notes, it will\\n all be on a single line.)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Each entry consists of ten unique signal patterns, a | delimiter, and finally\\n the four digit output value. Within an entry, the same wire/segment\\n connections are used (but you don't know what the connections actually are).\\n The unique signal patterns correspond to the ten different ways the submarine\\n tries to render a digit using the current wire/segment connections. Because 7\\n is the only digit that uses three segments, dab in the above example means\\n that to render a 7, signal lines d, a, and b are on. Because 4 is the only\\n digit that uses four segments, eafb means that to render a 4, signal lines e,\\n a, f, and b are on.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Using this information, you should be able to work out which combination of\\n signal wires corresponds to each of the ten digits. Then, you can decode the\\n four digit output value. Unfortunately, in the above example, all of the\\n digits in the output value (cdfeb fcadb cdfeb cdbaf) use five segments and\\n are more difficult to deduce.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" For now, focus on the easy digits. Consider this larger example:\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"     be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb |\\n     fdgacbe cefdb cefbgd gcbe\\n     edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec |\\n     fcgedb cgb dgebacf gc\\n     fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef |\\n     cg cg fdcagb cbg\\n     fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega |\\n     efabcd cedba gadfec cb\\n     aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga |\\n     gecf egdcabf bgf bfgea\\n     fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf |\\n     gebdcfa ecba ca fadegcb\\n     dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf |\\n     cefg dcbef fcge gbcadfe\\n     bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd |\\n     ed bcgafe cdgba cbgef\\n     egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg |\\n     gbdfcae bgc cg cgb\\n     gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc |\\n     fgae cfgab fg bagce\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Because the digits 1, 4, 7, and 8 each use a unique number of segments, you\\n should be able to tell which combinations of signals correspond to those\\n digits. Counting only digits in the output values (the part after | on each\\n line), in the above example, there are 26 instances of digits that use a\\n unique number of segments (highlighted above).\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" In the output values, how many times do digits 1, 4, 7, or 8 appear?\\n\", :nextjournal/viewer :markdown}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :xandrews.day08}}}")
app.init(docs)
</script></body></html>